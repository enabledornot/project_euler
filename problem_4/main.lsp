;; Checks to see if the strong split value is less than m for all palindrome generated by n
;; n palindrome generator
;; m max size 
(defun check_pali(n m)
    (cond
        ((< (strong_split (make_pal_num n)) m) n)
        (T (check_pali (- n 1) m))
    )
)
;; Strong split finds the largest of the 2 smallest possible factors of a number
;; It tries to keep the factors as balanced as possible by only multiplying the
;; least factor by the next prime number
;; then it returns the least factor at the end and gets passed back up through the array
;; n is the number being split
;; pl is the prime list which is generated by prime_factor
;; fa and fb are factor a and factor b and represent the 2 current factors
;; This method is used since it is easier to pass 2 variables to a function then to return 2 variables extract
;; Their contents and recombine them again
(defun strong_split(n)
    (strong_split_rec n (prime_factor n) 1 1)
)
(defun strong_split_rec(n pl fa fb)
    (cond
        ((null pl) (max fa fb))
        ((not_div n (car pl)) (strong_split_rec n (cdr pl) fa fb))
        ((> fa fb) (strong_split_rec (/ n (car pl)) pl (* fb (car pl)) fa))
        (T (strong_split_rec (/ n (car pl)) pl (* fa (car pl)) fb))
    )
)
;; Generates a list in descending order of all the factors of a prime number
;; Also bounded by the sqrt bound in order to improve performance
;; n is the number being factored
;; p is the current prime number being checked
;; pl is the prime list of previous prime numbers
(defun prime_factor(n)
    (prime_factor_rec n 2 '())
)
(defun prime_factor_rec(n p pl)
    (cond
        ((eql n 1) '())
        ((< (+ (isqrt n) 1) p) (list n))
        ((not_div n p) (prime_factor_rec n (+ p 1) pl))
        ((is_prime p pl) (append (prime_factor_rec (max_div n p) (+ p 1) (append pl (list p))) (list p)))
        (T (prime_factor_rec n (+ p 1) pl))
    )
)
;; Helper method that attempts to divide a number by a given number as many times as possible
;; n number
;; d divisor
(defun max_div(n d)
    (cond
        ((eql (mod n d) 0) (max_div (/ n d) d))
        (T n)
    )
)
;; Checks to see if a given number is prime.
;; In order for a number to be prime it must not be divisible by any other prime number
(defun is_prime(n pl)
    (cond
        ((null pl) T)
        ((eql (mod n (car pl) ) 0) nil)
        (T (is_prime n (cdr pl)))
    )
)
;; This just checks to see if a given number is not divisible by another number
;; a is the dividend
;; b is the divisor
(defun not_div(a b)
    (not (eql (mod a b) 0))
)
;; This takes a palindrome generator number and turns it into a palindrome list
;; The palindrome generator is used since it allows us to generate palindrome in descending order
;; n is the palindrome generator
;; p is the pass down list
(defun make_pal(n)
    (make_pal_rec n '())
)
(defun make_pal_rec(n p)
    (cond
        ((= n 0) p)
        (T (make_pal_rec (floor n 10) (append (list (mod n 10)) p (list (mod n 10)))))
    )
)
;; This function builds a palindrome number from a palindrome generator
;; It uses the function to generate the palindrome list and then converts it into 
;; An integer value
(defun make_pal_num(n)
    (make_pal_num_rec (make_pal n))
)
(defun make_pal_num_rec(l)
    (cond
        ((null l) 0)
        (T (+ (car l) (* (make_pal_num_rec (cdr l)) 10)))
    )
)
;; This performs the final calculation to solve the problem
;; It passes the max palindrome generator which is 3 digits long since 
;; We know that the factors cannot be greater than 3 digits.
;; We could also optimize since we know that 999^2 is our max number
;; Meaning our max palindrome is 997799 meaning our largest
;; palindrome generator is 997. However I have decided to leave it
;; at 999 since there is no program to handle that case
(print (make_pal_num (check_pali 999 1000)))